# -*- coding: utf-8 -*-
"""Programacao_Aplicada_I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YSt8VBDJgZHfgVauF_PeTa8S8yPPkfSp
"""

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterBoolean,
                       QgsRasterLayer,
                       QgsProcessingException,
                       QgsProcessingUtils)
from qgis import processing


class TrafegabilidadeAlgorithm(QgsProcessingAlgorithm):
    #Definindo os identificadores de seus parâmetros input e output
    VIA_DESLOCAMENTO = 'infra_via_deslocamento_l'
    DIST_BUFFER_VIA = 'DIST_BUFFER_VIA'
    VEGETACAO = 'cobter_vegetacao_a'
    MASSA_DAGUA = 'cobert_massa_dagua_a'
    TRECHO_DRENAGEM = 'elemnat_trecho_drenagem_l'
    DIST_BUFFER_TRECHO = 'DIST_BUFFER_TRECHO'
    DIST_BUFFER_MATA_CILIAR = 'DIST_BUFFER_MATA_CILIAR'
    AREA_CONSTRUIDA = 'cobert_area_construida_a'
    AREA_SEM_DADOS = 'area_sem_dados_a'
    PIXEL_SIZE = 'PIXEL_SIZE'
    MDT = 'MDT'
    OUTPUT = 'OUTPUT'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return TrafegabilidadeAlgorithm()

    def name(self):
        return 'cartadetrafegabilidade'

    def displayName(self):
        return self.tr('Carta de Trafegabilidade')

    def group(self):
        return self.tr('Exemplos')

    def groupId(self):
        return 'exemplos'

    def initAlgorithm(self, config=None):
        #Parâmetros já fornecidos
        self.addParameter(QgsProcessingParameterFeatureSource(self.VIA_DESLOCAMENTO,
                                                              self.tr('Via de Deslocamento'),
                                                              [QgsProcessing.TypeVectorLine]))
        self.addParameter(QgsProcessingParameterNumber(self.DIST_BUFFER_VIA,
                                                       self.tr('Distância de Buffer para Via de Deslocamento'),
                                                       QgsProcessingParameterNumber.Double,
                                                       defaultValue=10))

        #Adicionar camada vetorial de vegetação
        self.addParameter(QgsProcessingParameterFeatureSource(self.VEGETACAO,
                                                              self.tr('cobter_vegetacao_a'),
                                                              [QgsProcessing.TypeVectorPolygon]))

        #Adicionar camada vetorial de massa d'água
        self.addParameter(QgsProcessingParameterFeatureSource(self.MASSA_DAGUA,
                                                              self.tr('Massa d\'água'),
                                                              [QgsProcessing.TypeVectorPolygon]))

        #Adicionar camada vetorial de trecho de drenagem
        self.addParameter(QgsProcessingParameterFeatureSource(self.TRECHO_DRENAGEM,
                                                              self.tr('Trecho de Drenagem'),
                                                              [QgsProcessing.TypeVectorLine]))

        #Distância de buffer para trecho de drenagem
        self.addParameter(QgsProcessingParameterNumber(self.DIST_BUFFER_TRECHO,
                                                       self.tr('Distância de Buffer para Trecho de Drenagem'),
                                                       QgsProcessingParameterNumber.Double,
                                                       defaultValue=5))

        #Distância de buffer para mata ciliar
        self.addParameter(QgsProcessingParameterNumber(self.DIST_BUFFER_MATA_CILIAR,
                                                       self.tr('Distância de Buffer para Mata Ciliar'),
                                                       QgsProcessingParameterNumber.Double,
                                                       defaultValue=5))

        #Adicionar camada vetorial de área construída
        self.addParameter(QgsProcessingParameterFeatureSource(self.AREA_CONSTRUIDA,
                                                              self.tr('Área Construída'),
                                                              [QgsProcessing.TypeVectorPolygon]))

        #Adicionar camada vetorial de área sem dados
        self.addParameter(QgsProcessingParameterFeatureSource(self.AREA_SEM_DADOS,
                                                              self.tr('Área Sem Dados'),
                                                              [QgsProcessing.TypeVectorPolygon], optional=True))

        #Tamanho do pixel do raster de saída
        self.addParameter(QgsProcessingParameterNumber(self.PIXEL_SIZE,
                                                       self.tr('Tamanho do Pixel do Raster de Saída'),
                                                       QgsProcessingParameterNumber.Double,
                                                       defaultValue=10))

        #Camada raster do Modelo Digital de Terreno (MDT)
        self.addParameter(QgsProcessingParameterRasterLayer(self.MDT,
                                                            self.tr('Modelo Digital de Terreno')))

        #Definir a saída do raster
        self.addParameter(QgsProcessingParameterRasterDestination(self.OUTPUT,
                                                                  self.tr('Carta de Trafegabilidade')))


        def processAlgorithm(self, parameters, context, feedback):
        via_deslocamento = self.parameterAsVectorLayer(parameters, self.VIA_DESLOCAMENTO, context)
        vegetacao = self.parameterAsVectorLayer(parameters, self.VEGETACAO, context)
        massa_dagua = self.parameterAsVectorLayer(parameters, self.MASSA_DAGUA, context)
        DRENAGEM = self.parameterAsVectorLayer(parameters, self.TRECHO_DRENAGEM, context)
        contruida = self.parameterAsVectorLayer(parameters, self.AREA_CONSTRUIDA, context)
        sem_dados = self.parameterAsVectorLayer(parameters, self.AREA_SEM_DADOS, context)

        
        expressao_filtro = "\"administracao\" = 'Desconhecida'"

        via_deslocamento_filtrada = processing.run("native:extractbyexpression", {
            'INPUT': parameters[self.VIA_DESLOCAMENTO],
            'EXPRESSION': expressao_filtro,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        via_deslocamento_filtrada_desc = processing.run("qgis:extractbyexpression", {
            'INPUT': parameters[self.VEGETACAO],
            'EXPRESSION': "\"tipo\" = 0",
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        floresta_densa_esparsa = processing.run("qgis:extractbyexpression", {
            'INPUT': parameters[self.VEGETACAO],
            'EXPRESSION': "\"tipo\" = 601 OR \"tipo\" = 602",
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        vegetacao_restritiva = processing.run("qgis:extractbyexpression", {
            'INPUT': parameters[self.VEGETACAO],
            'EXPRESSION': "\"tipo\" != 601 AND \"tipo\" != 602 AND \"tipo\" != 1000",
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        terreno_exposto_desconhecido = processing.run("qgis:extractbyexpression", {
            'INPUT': parameters[self.VEGETACAO],
            'EXPRESSION': "\"tipo\" = 1000",
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']


        buffer_via_deslocamento_filtrada_desc = processing.run("native:buffer", {
            'INPUT': via_deslocamento_filtrada_desc,
            'DISTANCE': parameters[self.DIST_BUFFER_VIA],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

        buffer_via_deslocamento = processing.run("native:buffer", {
            'INPUT': via_deslocamento,
            'DISTANCE': parameters[self.DIST_BUFFER_VIA],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        buffer_via_deslocamento_filtrofedest = processing.run("native:buffer", {
            'INPUT': via_deslocamento_filtrada,
            'DISTANCE': parameters[self.DIST_BUFFER_VIA],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        buffer_vegetacao_restritiva = processing.run("native:buffer", {
            'INPUT': vegetacao_restritiva,
            'DISTANCE': parameters[self.DIST_BUFFER_MATA_CILIAR],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        buffer_floresta_densa_esparsa = processing.run("native:buffer", {
            'INPUT': floresta_densa_esparsa,
            'DISTANCE': parameters[self.DIST_BUFFER_MATA_CILIAR],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        buffer_terreno_exposto_desconhecido = processing.run("native:buffer", {
            'INPUT': terreno_exposto_desconhecido,
            'DISTANCE': parameters[self.DIST_BUFFER_MATA_CILIAR],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        buffer_mata_ciliar = processing.run("native:buffer", {
            'INPUT': vegetacao,
            'DISTANCE': parameters[self.DIST_BUFFER_MATA_CILIAR],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        buffer_trecho_drenagem = processing.run("native:buffer", {
            'INPUT': DRENAGEM,
            'DISTANCE': parameters[self.DIST_BUFFER_TRECHO],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
#Camadas finais
        camadas_impeditivas = [buffer_floresta_densa_esparsa, massa_dagua, buffer_trecho_drenagem, buffer_mata_ciliar]  
        camada_impeditiva_combinada = processing.run("qgis:mergevectorlayers", {
            'LAYERS': camadas_impeditivas,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        
        camadas_restritivo = [buffer_vegetacao_restritiva, contruida, buffer_via_deslocamento_filtrofedest]  
        camada_restritivo_combinada = processing.run("qgis:mergevectorlayers", {
            'LAYERS': camadas_restritivo,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        camadas_adequado = [buffer_terreno_exposto_desconhecido, via_deslocamento_filtrada_desc]  
        camada_adequado_combinada = processing.run("qgis:mergevectorlayers", {
            'LAYERS': camadas_adequado,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']
        camadas_desconhecido = [sem_dados]  
        camada_desconhecido_combinada = processing.run("qgis:mergevectorlayers", {
            'LAYERS': camadas_desconhecido,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)['OUTPUT']

        #Consolidação em um raster de saída
        #Rasterização da camada impeditiva
        #Definir o tamanho do pixel e a extensão para a rasterização
        pixel_size = parameters[self.PIXEL_SIZE]
        extent1 = camada_impeditiva_combinada.extent()
        width1 = int((extent1.xMaximum() - extent1.xMinimum()) / pixel_size)
        height1 = int((extent1.yMaximum() - extent1.yMinimum()) / pixel_size)
        extent2 = camada_restritivo_combinada.extent()
        width2 = int((extent2.xMaximum() - extent2.xMinimum()) / pixel_size)
        height2 = int((extent2.yMaximum() - extent2.yMinimum()) / pixel_size)
        extent3 = camada_adequado_combinada.extent()
        width3 = int((extent3.xMaximum() - extent3.xMinimum()) / pixel_size)
        height3 = int((extent3.yMaximum() - extent3.yMinimum()) / pixel_size)
        extent4 = camada_desconhecido_combinada.extent()
        width4 = int((extent4.xMaximum() - extent4.xMinimum()) / pixel_size)
        height4 = int((extent4.yMaximum() - extent4.yMinimum()) / pixel_size)


        #Caminho para o raster de saída temporário
        raster_impeditivo_path = processing.run("gdal:rasterize", {
            'INPUT': camada_impeditiva_combinada,
            'FIELD': 3,  # Atribuir o valor 3 para áreas impeditivas
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
            'WIDTH': width1,
            'HEIGHT': height1,
            'EXTENT': extent1,
            'NODATA': 0,  # Supondo que 0 é usado para áreas desconhecidas
            'DATA_TYPE': 5,  # Byte
            'INIT': 0,
            'INVERT': False
        }, context=context, feedback=feedback)['OUTPUT']

        #Camada restritiva
        raster_restritivo_path = processing.run("gdal:rasterize", {
            'INPUT': camada_restritivo_combinada,
            'FIELD': 2,  # Valor para áreas restritivas
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
            'WIDTH': width2,
            'HEIGHT': height2,
            'EXTENT': extent2,
            'NODATA': 0,
            'DATA_TYPE': 5,
            'INIT': 0,
            'INVERT': False
        }, context=context, feedback=feedback)['OUTPUT']

        #Camada adequada
        raster_adequado_path = processing.run("gdal:rasterize", {
            'INPUT': camada_adequado_combinada,
            'FIELD': 1,  # Valor para áreas adequadas
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
            'WIDTH': width3,
            'HEIGHT': height3,
            'EXTENT': extent3,
            'NODATA': 0,
            'DATA_TYPE': 5,
            'INIT': 0,
            'INVERT': False
        }, context=context, feedback=feedback)['OUTPUT']

        raster_desconhecido_path = processing.run("gdal:rasterize", {
            'INPUT': camada_desconhecido_combinada,
            'FIELD': 0,  # Valor para áreas adequadas
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
            'WIDTH': width4,
            'HEIGHT': height4,
            'EXTENT': extent4,
            'NODATA': 0,
            'DATA_TYPE': 5,
            'INIT': 0,
            'INVERT': False
        }, context=context, feedback=feedback)['OUTPUT']

        #Retornar o raster de saída
        return {self.OUTPUT: 'caminho_para_o_raster_de_saida_final'}

#Se a parte inicial estivesse funcionando iriamos usar algo com essa estrutura para a priorização das camas finais:

import numpy as np
from osgeo import gdal

#Função para ler um raster e retornar como array NumPy
def read_raster_as_array(raster_path):
    ds = gdal.Open(raster_path)
    band = ds.GetRasterBand(1)
    array = band.ReadAsArray()
    return array

#Carregar os rasters como arrays NumPy
raster_impeditivo = read_raster_as_array(raster_impeditivo_path)
raster_restritivo = read_raster_as_array(raster_restritivo_path)
raster_adequado = read_raster_as_array(raster_adequado_path)
raster_desconhecido = read_raster_as_array(raster_desconhecido_path)

#Preparar o raster final com a mesma forma dos rasters de entrada
raster_final = np.zeros_like(raster_impeditivo)

#Definir os valores no raster final baseado na prioridade
raster_final[raster_desconhecido == 0] = 0  # Prioridade mais alta para desconhecido
raster_final[(raster_adequado == 1) & (raster_final == 0)] = 1
raster_final[(raster_restritivo == 2) & (raster_final == 0)] = 2
raster_final[(raster_impeditivo == 3) & (raster_final == 0)] = 3

#Salvar o raster final usando GDAL
driver = gdal.GetDriverByName('GTiff')
out_ds = driver.Create('caminho_para_o_raster_final.tif', raster_impeditivo.shape[1], raster_impeditivo.shape[0], 1, gdal.GDT_Byte)
out_band = out_ds.GetRasterBand(1)
out_band.WriteArray(raster_final)
out_band.SetNoDataValue(0)
out_ds.SetGeoTransform(ds_impeditivo.GetGeoTransform())  # Assume ds_impeditivo como o dataset GDAL do raster impeditivo
out_ds.SetProjection(ds_impeditivo.GetProjection())

#Fechar dataset
out_band.FlushCache()
out_ds = None
